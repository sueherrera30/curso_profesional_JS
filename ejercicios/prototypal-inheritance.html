<html>
  <head>
    <title>Herencia Prototipal</title>
  </head>

  <body>
    <a href="/ejercicios/">Go back</a>
    <p><em>Abre la consola</em></p>

    <h1>
      <code>SomeObject.prototype</code> es un objeto donde definimos el
      prototipo de las instancias de <code>SomeObject</code>. Es decir, las
      instancias de <code>SomeObject</code> van a "heredar" de
      <code>SomeObject.prototype</code>.
      <br />
      <br />
      <code>SomeObject.[[Prototype]]</code> es el prototipo de
      <code>SomeObject</code>. Es decir, <code>SomeObject</code> "hereda" de
      <code>SomeObject.prototype</code>.
    </h1>

    <script>
      // HERENCIA PROTOTIPAL:
      // cuando instanciamos el prototipo, se heredan sus propiedades pero no se ven directsmente, estan el proto, si se inspecciona se veran las funciones descritas,
      //pero funcionaran hasta que las nombremos.
      // modelo para heredar valores de otros objetos.
      //ojo: 
      // al escribir dolo el nombre de una funcion, sin parentesis se esta referenciando, y al inspecconar se vera estructura de funcion, sin embargo al poner pasrentesis se llama.

       function Hero(name,instrument){
          this.name = name;
          this.instrument = instrument;
       }

       Hero.prototype.saludar = function(){
        console.log(`hola yo soy ${this.name}, y te protegeré en nombre de la luna y toco el  ${this.instrument} `);
       }
       const serena = new Hero('sailor moon', 'cello');
       serena.saludar();
       console.log( 'name:', serena.name) // poner  this.name no funciona, pues ya estamos fuera del objeto.// en lugar llamamos a la instacia y entramos a sus propidades,
       console.log( 'instrumento:' , serena.instrument)
       console.log( 'instrumento:' , serena.saludar) // imprime la funcion en si 
       console.log( 'instrumento:' , serena.saludar())// sale undefined

       //tenemos un metodo que viene de objecto, este sirve para saber si algo le pertrenece directsmente a un objeto o s i lo toma prestado atraves de herencia, se le aplica al objeto
       console.log(serena.hasOwnProperty('name'))  //esto debe dar true
       console.log(serena.hasOwnProperty('saludar'))  //esto debe dar false, ya no es de serena, no tomo prestado de hero ?-- ?

       // este metodo nos regresara  el PROTOTIPO
       const sernaPrototypeOf = Object.getPrototypeOf(serena);
       console.log(sernaPrototypeOf);

       //comparamos:
       sernaPrototypeOf === Hero.prototype; // esto debe dar true, se esta refierendo al mismo objeto incluso en memoria.

       // JS va buscando en los prototypes. si n oesta en prototype, no no esta ahi esta el prototype de prototype que al final es OBJECT 
       // OBJECT es el punto de partida de todos los objetos que hagamos es com oel windows, es el general de todo,ahi incluye las funciones, que al final las funciones tambien son
       //objetos en JS.
       // DIFERENCIAR entre los dos prototypes:
       // cuando tenemos un OBJECT.PROTOTYPE l oque estamos haciendo ahi es DEFINIENDO PROPIEDADES QUE VAN A HEREDAR TODAS LAS INSTANCIAS de some object.
       //
      









      // function Hero(name) {
      //   this.name = name;
      // }

      // Hero.prototype.saludar = function() {
      //   console.log(`Hola, soy ${this.name}.`);
      // };

      // const zelda = new Hero('Zelda');

      // // propiedades de la instancia
      // console.log('Name:', zelda.name);
      // // propiedades de la "clase"
      // console.log('Saludar:', zelda.saludar);

      // // propiedades heredadas ej: toString
      // console.log('toString:', zelda.toString);

      // // hasOwnProperty (de dónde sale toString o esto?)
      // console.log(
      //   'zelda.hasOwnProperty("saludar"):',
      //   zelda.hasOwnProperty('saludar')
      // );

      // inspeccionemos el prototipo del zelda
      // inspeccionemos el prototipo del Hero
      // inspeccionemos el prototipo del Object
    </script>
  </body>
</html>
